<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chord Shuffler</title>

  <!-- SVGuitar (UMD). If this fails to load, the app still runs but diagrams won't render. -->
  <script src="https://unpkg.com/svguitar@1.1.3/dist/svguitar.umd.js"></script>

  <style>
    :root{
      --bg:#0b0f17;
      --card:#121a2a;
      --card2:#0f1624;
      --text:#f3f6ff;
      --muted:rgba(243,246,255,.68);
      --accent:#7c5cff;
      --accent2:#23d5ab;
      --danger:#ff4d6d;
      --border:rgba(255,255,255,.10);
      --shadow: 0 10px 25px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 0%, rgba(124,92,255,.22), transparent 60%),
                  radial-gradient(1200px 900px at 90% 10%, rgba(35,213,171,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    a{ color:inherit; }
    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 14px 28px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 14px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .logo{
      width:38px;
      height:38px;
      border-radius: 12px;
      background:
        linear-gradient(135deg, rgba(124,92,255,.95), rgba(35,213,171,.85));
      box-shadow: 0 12px 25px rgba(0,0,0,.35);
      display:grid;
      place-items:center;
      font-weight:800;
      letter-spacing:-.03em;
    }
    .brand h1{
      font-size: 18px;
      margin:0;
      letter-spacing:-.02em;
      line-height:1.1;
    }
    .brand .sub{
      font-size: 12px;
      color:var(--muted);
      margin-top:2px;
    }
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--border);
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      white-space:nowrap;
    }

    .tabs{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      margin: 14px 0 14px;
    }
    .tab{
      padding:10px 12px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      cursor:pointer;
      font-weight:600;
      font-size: 13px;
      user-select:none;
      color:#fff;
      transition: transform .08s ease, background .12s ease;
    }
    .tab:hover{ transform: translateY(-1px); }
    .tab.active{
      background: rgba(124,92,255,.22);
      border-color: rgba(124,92,255,.35);
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent 35%),
                  var(--card);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h2{
      margin:0 0 10px;
      font-size: 15px;
      letter-spacing:-.01em;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .muted{ color:var(--muted); }
    .small{ font-size:12px; color:var(--muted); }
    .divider{
      height:1px;
      background: var(--border);
      margin: 12px 0;
    }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .btn{
      border:1px solid var(--border);
      color:#fff;
      background: rgba(0,0,0,.18);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      font-weight:700;
      font-size: 13px;
      transition: transform .08s ease, background .12s ease;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn.primary{
      background: rgba(124,92,255,.22);
      border-color: rgba(124,92,255,.35);
    }
    .btn.good{
      background: rgba(35,213,171,.16);
      border-color: rgba(35,213,171,.30);
    }
    .btn.danger{
      background: rgba(255,77,109,.14);
      border-color: rgba(255,77,109,.30);
    }

    .field{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    label{
      font-size:12px;
      color: var(--muted);
      font-weight:600;
    }
    input[type="number"], input[type="text"], select{
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      color: var(--text);
      padding: 10px 10px;
      border-radius: 12px;
      font-size: 13px;
      outline:none;
      min-width: 90px;
    }
    input[type="checkbox"]{ transform: translateY(1px); }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      padding: 10px 10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      font-size: 13px;
      user-select:none;
    }

    .lists{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 820px){
      .lists{ grid-template-columns: 1fr 1fr; }
    }

    .listbox{
      background: rgba(0,0,0,.16);
      border:1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
    }
    .listbox h3{
      margin:0 0 10px;
      font-size: 13px;
      letter-spacing:-.01em;
    }
    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      max-height: 270px;
      overflow:auto;
      padding-right: 6px;
    }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      font-weight:650;
      color:#fff;
      transition: background .12s ease, transform .08s ease;
    }
    .chip:hover{ transform: translateY(-1px); }
    .chip.on{
      background: rgba(124,92,255,.24);
      border-color: rgba(124,92,255,.35);
    }

    .trainerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
    }
    .bigChord{
      font-size: 28px;
      font-weight: 900;
      letter-spacing:-.03em;
      margin: 0;
      line-height:1.05;
    }
    .subChord{
      margin-top: 6px;
      font-size: 13px;
      color: var(--muted);
      font-weight:650;
    }

    .voicingGrid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .voicingCard{
      border:1px solid var(--border);
      background: rgba(0,0,0,.15);
      border-radius: 16px;
      padding: 12px;
      position:relative;
      overflow:hidden;
    }
    .voicingHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .vcTitle{
      font-weight: 900;
      font-size: 22px;
      letter-spacing:-.02em;
      line-height:1.1;
    }
    .vcSub{
      font-size: 18px;
      color: var(--muted);
      font-weight: 800;
      margin-top: 2px;
      letter-spacing:-.01em;
    }
    .starBtn{
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      cursor:pointer;
      display:grid;
      place-items:center;
      user-select:none;
      flex: 0 0 auto;
      font-size: 24px;
      color:#fff;
    }
    .starBtn.on{
      background: rgba(35,213,171,.18);
      border-color: rgba(35,213,171,.35);
    }

    .svgWrap{
      display:flex;
      justify-content:center;
      align-items:center;
      min-height: 230px;
      position:relative;
    }
    .posLabel{
      position:absolute;
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 44px;
      font-weight: 900;
      letter-spacing:-.02em;
      color: var(--muted);
      text-shadow: 0 2px 0 rgba(0,0,0,.25);
      user-select:none;
      pointer-events:none;
    }

    .noteRow{
      margin: 6px auto 0;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      justify-items: center;
      align-items: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      line-height: 1.1;
      color: var(--muted);
    }
    .noteRow.aligned{
      position: relative;
      display: block;
      height: 1.6em;
    }
    .noteRow.aligned .noteLabel{
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      white-space: nowrap;
      min-width: 2.5ch;
      text-align: center;
    }
    .noteLabel{
      text-align: center;
      min-height: 1em;
      white-space: nowrap;
    }

    /* Error banner */
    .err{
      display:none;
      margin-top: 12px;
      border: 1px solid rgba(255,77,109,.35);
      background: rgba(255,77,109,.10);
      border-radius: 14px;
      padding: 10px 12px;
      color: #ffd7de;
      font-size: 13px;
      white-space: pre-wrap;
    }

    /* v11: make all button-like text white */
    .btn, .tab, .chip, button{ color:#fff !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">CS</div>
        <div>
          <h1>Chord Shuffler</h1>
          <div class="sub">Select roots + chord types, then shuffle and practice voicings.</div>
        </div>
      </div>
      <span class="pill">build v11 • phone/tablet friendly • no spend</span>
    </header>

    <div class="tabs">
      <div class="tab active" id="tabSetup">Setup</div>
      <div class="tab" id="tabTrainer">Trainer</div>
      <div class="tab" id="tabFaves">Favourites</div>
    </div>

    <div id="err" class="err"></div>

    <!-- SETUP -->
    <div id="screenSetup" class="grid">
      <div class="card">
        <div class="row">
          <h2>Selections</h2>
          <div class="controls">
            <div class="btn" id="btnSelectAllRoots">All roots</div>
            <div class="btn" id="btnClearRoots">Clear roots</div>
            <div class="btn" id="btnSelectAllTypes">All types</div>
            <div class="btn" id="btnClearTypes">Clear types</div>
          </div>
        </div>

        <div class="lists" style="margin-top:10px;">
          <div class="listbox">
            <h3>Root notes</h3>
            <div class="chips" id="rootChips"></div>
          </div>

          <div class="listbox">
            <h3>Chord types</h3>
            <div class="chips" id="typeChips"></div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <div class="field">
            <div class="toggle"><input type="checkbox" id="chkPreferTop" checked> <label for="chkPreferTop">Prefer top-string & 2–4 patterns</label></div>
            <div class="toggle"><input type="checkbox" id="chkShowTriads" checked> <label for="chkShowTriads">Triads</label></div>
            <div class="toggle"><input type="checkbox" id="chkShowFour" checked> <label for="chkShowFour">4-note</label></div>
            <div class="toggle"><input type="checkbox" id="chkAllowBassTop" checked> <label for="chkAllowBassTop">Allow bass+top (2–5 only if 5th is root)</label></div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <div class="field">
            <label>Fret band</label>
            <input type="number" id="numMinFret" value="5" min="0" max="20" />
            <span class="muted">to</span>
            <input type="number" id="numMaxFret" value="12" min="0" max="24" />
          </div>
          <div class="field">
            <label>Max span (frets)</label>
            <input type="number" id="numMaxSpan" value="4" min="1" max="6" />
          </div>
          <div class="field">
            <label>Max diagrams per Display</label>
            <input type="number" id="numMaxVoicings" value="12" min="1" max="60" />
            <span class="small">Limits how many diagrams show when you tap Display.</span>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <div class="field">
            <label>Mode</label>
            <select id="selMode">
              <option value="shuffle">Shuffle</option>
              <option value="deck">Deck (no repeats until exhausted)</option>
            </select>
          </div>
          <div class="field">
            <div class="toggle"><input type="checkbox" id="chkAutoAdvance"> <label for="chkAutoAdvance">Auto-advance</label></div>
            <label>Every (seconds)</label>
            <input type="number" id="numAutoSecs" value="6" min="1" max="60" />
          </div>
          <div class="controls">
            <div class="btn primary" id="btnGoTrainer">Go to Trainer</div>
            <div class="btn" id="btnSavePreset">Save preset</div>
            <select id="selPreset"></select>
            <div class="btn danger" id="btnDeletePreset">Delete preset</div>
          </div>
        </div>
      </div>
    </div>

    <!-- TRAINER -->
    <div id="screenTrainer" class="grid" style="display:none;">
      <div class="card">
        <div class="trainerTop">
          <div>
            <h2 class="bigChord" id="curChordName">—</h2>
            <div class="subChord" id="curChordMeta">Press Play to start.</div>
          </div>
          <div class="controls">
            <div class="btn primary" id="btnPlay">Play</div>
            <div class="btn good" id="btnDisplay">Display</div>
            <div class="btn" id="btnNext">Next</div>
          </div>
        </div>

        <div class="divider"></div>

        <div id="voicingArea"></div>
      </div>
    </div>

    <!-- FAVES -->
    <div id="screenFaves" class="grid" style="display:none;">
      <div class="card">
        <div class="row">
          <h2>Favourites</h2>
          <div class="controls">
            <div class="btn" id="btnFavesRefresh">Refresh</div>
            <div class="btn danger" id="btnFavesClearAll">Clear all favourites</div>
          </div>
        </div>
        <div class="small">Filter your starred voicings by root and chord family.</div>

        <div class="divider"></div>

        <div class="lists">
          <div class="listbox">
            <h3>Root notes</h3>
            <div class="chips" id="favRootChips"></div>
            <div class="controls" style="margin-top:10px;">
              <div class="btn" id="btnFavRootsAll">All</div>
              <div class="btn" id="btnFavRootsNone">None</div>
            </div>
          </div>
          <div class="listbox">
            <h3>Families</h3>
            <div class="chips" id="favFamChips"></div>
            <div class="controls" style="margin-top:10px;">
              <div class="btn" id="btnFavFamAll">All</div>
              <div class="btn" id="btnFavFamNone">None</div>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <div id="favesArea"></div>
      </div>
    </div>

  </div>

<script>
/* -------------------------
   State
--------------------------*/
const state = {
  selectedRoots: new Set(),
  selectedTypes: new Set(),
  preferTop: true,
  showTriads: true,
  showFour: true,
  allowBassTop: true,
  minFret: 5,
  maxFret: 12,
  maxSpan: 4,
  maxVoicings: 12,
  mode: "shuffle",
  autoAdvance: false,
  autoSecs: 6,
  presetName: "",
  current: null,
  deck: [],
  deckIdx: 0,
};

const STORAGE_KEYS = {
  presets: "cs_presets_v2",
  faves: "cs_faves_v2"
};

function showError(msg){
  const el = document.getElementById("err");
  el.style.display = "block";
  el.textContent = msg;
}
function clearError(){
  const el = document.getElementById("err");
  el.style.display = "none";
  el.textContent = "";
}

window.addEventListener("error", (e)=>{
  showError("JavaScript error:\n" + (e.message||e.error||"Unknown") + "\n@ " + (e.filename||"") + ":" + (e.lineno||"") );
});

/* -------------------------
   Theory helpers
--------------------------*/
const NOTE_NAMES_SHARP = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_TO_PC = {
  "C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11
};
// display roots list A..G# as you requested (A, A#, B, C...)
const ROOT_DISPLAY = ["A","A#","B","C","C#","D","D#","E","F","F#","G","G#"];

const STRING_PCS_STD = { // standard tuning EADGBe => string number 6..1
  6: NOTE_TO_PC["E"],
  5: NOTE_TO_PC["A"],
  4: NOTE_TO_PC["D"],
  3: NOTE_TO_PC["G"],
  2: NOTE_TO_PC["B"],
  1: NOTE_TO_PC["E"],
};

function pcToName(pc){
  return NOTE_NAMES_SHARP[((pc%12)+12)%12];
}
function nameToPc(name){
  return NOTE_TO_PC[name];
}
function pcAt(stringNum, fret){
  const base = STRING_PCS_STD[stringNum];
  return (base + fret) % 12;
}

/* -------------------------
   Chord types
   Based on all-guitar-chords.com style symbols
--------------------------*/
const CHORD_TYPES = [
  // Triads / basic
  {sym:"maj", label:"maj", require:[0,4,7]},
  {sym:"min", label:"min", require:[0,3,7]},
  {sym:"dim", label:"dim", require:[0,3,6]},
  {sym:"aug", label:"aug", require:[0,4,8]},
  {sym:"sus2", label:"sus2", require:[0,2,7]},
  {sym:"sus4", label:"sus4", require:[0,5,7]},
  {sym:"5", label:"5", require:[0,7]},

  // 6 / 7 / maj7 / m7 / mMaj7 / dim7 / m7b5
  {sym:"6", label:"6", require:[0,4,7,9]},
  {sym:"m6", label:"m6", require:[0,3,7,9]},
  {sym:"7", label:"7", require:[0,4,7,10]},
  {sym:"maj7", label:"maj7", require:[0,4,7,11]},
  {sym:"m7", label:"m7", require:[0,3,7,10]},
  {sym:"mMaj7", label:"mMaj7", require:[0,3,7,11]},
  {sym:"dim7", label:"dim7", require:[0,3,6,9]},
  {sym:"m7b5", label:"m7b5", require:[0,3,6,10]},

  // 9s
  {sym:"9", label:"9", require:[0,4,7,10,2]},
  {sym:"maj9", label:"maj9", require:[0,4,7,11,2]},
  {sym:"m9", label:"m9", require:[0,3,7,10,2]},
  {sym:"7b9", label:"7(b9)", require:[0,4,7,10,1]},
  {sym:"7#9", label:"7(#9)", require:[0,4,7,10,3]},
  {sym:"7b5b9", label:"7(b5,b9)", require:[0,4,6,10,1]},
  {sym:"7#5#9", label:"7(#5,#9)", require:[0,4,8,10,3]},

  // 11s
  {sym:"11", label:"11", require:[0,4,7,10,2,5]},
  {sym:"m11", label:"m11", require:[0,3,7,10,2,5]},
  {sym:"maj11", label:"maj11", require:[0,4,7,11,2,5]},
  {sym:"7#11", label:"7(#11)", require:[0,4,7,10,6]},
  {sym:"maj9#11", label:"maj9(#11)", require:[0,4,7,11,2,6]},

  // 13s
  {sym:"13", label:"13", require:[0,4,7,10,2,9]},
  {sym:"m13", label:"m13", require:[0,3,7,10,2,9]},
  {sym:"maj13", label:"maj13", require:[0,4,7,11,2,9]},
  {sym:"13b9", label:"13(b9)", require:[0,4,7,10,1,9]},
  {sym:"13#11", label:"13(#11)", require:[0,4,7,10,6,9]},
  {sym:"maj13#11", label:"maj13(#11)", require:[0,4,7,11,2,6,9]},
];

function chordTypeDef(sym){
  return CHORD_TYPES.find(t => t.sym === sym);
}

/* -------------------------
   Families for favourites screen
   Dominant 7th = contains major 3rd (4) and b7 (10)
--------------------------*/
const FAM = [
  {id:"maj", label:"Maj"},
  {id:"min", label:"Min"},
  {id:"dom7", label:"Dominant 7th"},
  {id:"dim", label:"Dim"},
  {id:"aug", label:"Aug"},
  {id:"other", label:"Other"},
];

function famForType(typeSym){
  const def = chordTypeDef(typeSym);
  if(!def) return "other";
  const hasM3 = def.require.includes(4);
  const hasm3 = def.require.includes(3);
  const hasb7 = def.require.includes(10);
  const hasMaj7 = def.require.includes(11);
  const hasDim5 = def.require.includes(6);
  const hasAug5 = def.require.includes(8);

  if(typeSym === "maj" || typeSym === "maj7" || typeSym.startsWith("maj")) return "maj";
  if(typeSym === "min" || typeSym.startsWith("m") || typeSym.startsWith("m7") || typeSym.startsWith("m9") || typeSym.startsWith("m11") || typeSym.startsWith("m13")) return "min";

  if(hasM3 && hasb7) return "dom7";
  if(typeSym.includes("dim") || (hasm3 && hasDim5)) return "dim";
  if(typeSym.includes("aug") || hasAug5) return "aug";

  if(hasM3 && hasMaj7) return "maj";
  if(hasm3 && (hasb7 || hasMaj7)) return "min";

  return "other";
}

/* -------------------------
   Patterns (string sets)
   Priorities: 1-3 and 2-4; 2-5 OK if 5th string is root; omit root ok for 3+ tone chords
   Strings numbered 1=top e, 2=B ... 6=low E.
--------------------------*/
const PATTERNS = [
  {id:"t123", label:"Triad 1-3", strings:[1,2,3], kind:"triad", weight: 10},
  {id:"t234", label:"Triad 2-4", strings:[2,3,4], kind:"triad", weight: 12},
  {id:"t345", label:"Triad 3-5", strings:[3,4,5], kind:"triad", weight: 5, bassTop:true},
  {id:"t456", label:"Triad 4-6", strings:[4,5,6], kind:"triad", weight: 1, bassTop:true},

  {id:"f1234", label:"4-note 1-4", strings:[1,2,3,4], kind:"four", weight: 10},
  {id:"f2345", label:"4-note 2-5", strings:[2,3,4,5], kind:"four", weight: 12, rootString:5},
  {id:"f3456", label:"4-note 3-6", strings:[3,4,5,6], kind:"four", weight: 2, bassTop:true},
];

function minNotesNeeded(typeDef){
  // allow triad patterns for extended chords by requiring only core tones
  // We'll use meetsChordRequirements to enforce required tones; here just ensure pattern isn't absurdly small
  return Math.min(typeDef.require.length, 4);
}

/* -------------------------
   Voicing generation
--------------------------*/
function intervalsPresent(rootPc, fretsByString){
  const set = new Set();
  for(const [sStr, f] of Object.entries(fretsByString)){
    const s = Number(sStr);
    const pc = pcAt(s, f);
    const iv = (pc - rootPc + 12) % 12;
    set.add(iv);
  }
  return set;
}

function meetsChordRequirements(rootPc, typeDef, pattern, fretsByString){
  const present = intervalsPresent(rootPc, fretsByString);
  const noteCount = Object.keys(fretsByString).length;

  // Root omission allowed for 3+ tone chords
  const allowRootOmit = (typeDef.require.length >= 3);

  let must = typeDef.require.slice();
  if(allowRootOmit){
    must = must.filter(iv => iv !== 0);
  }

  if(noteCount < must.length) return false;

  for(const req of must){
    if(!present.has(req)) return false;
  }

  if(pattern?.rootString){
    const s = pattern.rootString;
    const f = fretsByString[s];
    if(f === undefined) return false;
    const interval = (pcAt(s, f) - rootPc + 12) % 12;
    if(interval !== 0) return false;
  }

  if(!allowRootOmit && typeDef.require.includes(0) && !present.has(0)) return false;

  return true;
}

function withinBandAndSpan(fretsByString){
  const frets = Object.values(fretsByString).map(Number);
  if(frets.length === 0) return false;
  const minF = Math.min(...frets);
  const maxF = Math.max(...frets);
  if(minF < state.minFret || maxF > state.maxFret) return false;
  const span = maxF - minF;
  return span <= state.maxSpan;
}

function possibleFretsForString(rootPc, typeDef, stringNum){
  const options = [];
  // We allow any chord tone (incl root), but bias is handled by scoring.
  // Generate frets in the band that hit any required interval or root/5 etc.
  const allowedIntervals = new Set(typeDef.require);
  // Also allow extra chord tones to permit some omissions/voicings; we'll allow any of:
  // - required tones
  // - root
  // - perfect 5
  allowedIntervals.add(0);
  allowedIntervals.add(7);

  for(let f=state.minFret; f<=state.maxFret; f++){
    const iv = (pcAt(stringNum, f) - rootPc + 12) % 12;
    if(allowedIntervals.has(iv)) options.push(f);
  }
  return options;
}

function scoreVoicing(rootPc, typeDef, pattern, fretsByString){
  const present = intervalsPresent(rootPc, fretsByString);
  let score = 0;

  // Root optional but a small reward when present
  if(present.has(0)) score += 2;

  for(const req of typeDef.require){
    if(req !== 0 && present.has(req)) score += 6;
  }

  score += Math.min(present.size, 6) * 2;

  if(state.preferTop){
    if(pattern.id === "t123" || pattern.id === "t234") score += 6;
    if(pattern.id === "f1234" || pattern.id === "f2345") score += 4;
  }
  score += pattern.weight || 0;

  const frets = Object.values(fretsByString).map(Number);
  const span = Math.max(...frets) - Math.min(...frets);
  score += (state.maxSpan - span) * 1.3;

  return score;
}

function generateVoicings(rootPc, typeSym){
  const typeDef = chordTypeDef(typeSym);
  if(!typeDef) return [];

  const patterns = PATTERNS.filter(p => {
    if(p.kind === "triad" && !state.showTriads) return false;
    if(p.kind === "four" && !state.showFour) return false;
    if(p.bassTop && !state.allowBassTop) return false;
    return true;
  });

  const results = [];
  const seen = new Set();

  for(const pattern of patterns){
    if(pattern.strings.length < minNotesNeeded(typeDef)) continue;

    const choices = pattern.strings.map(s => possibleFretsForString(rootPc, typeDef, s));
    if(choices.some(arr => arr.length === 0)) continue;

    const pick = (idx, acc) => {
      if(idx === pattern.strings.length){
        if(!withinBandAndSpan(acc)) return;
        if(!meetsChordRequirements(rootPc, typeDef, pattern, acc)) return;

        const frets6 = [];
        for(let s=6; s>=1; s--){
          frets6.push(acc[s] ?? "x");
        }
        const key = `${typeSym}|${rootPc}|${frets6.join(",")}|${pattern.id}`;
        if(seen.has(key)) return;
        seen.add(key);

        const sc = scoreVoicing(rootPc, typeDef, pattern, acc);
        results.push({ rootPc, typeSym, pattern, fretsByString: { ...acc }, score: sc });
        return;
      }
      const s = pattern.strings[idx];
      for(const f of choices[idx]){
        acc[s] = f;
        pick(idx+1, acc);
        delete acc[s];
      }
    };
    pick(0, {});
  }

  results.sort((a,b) => b.score - a.score);
  return results.slice(0, Math.max(1, state.maxVoicings));
}

/* -------------------------
   Display helpers
--------------------------*/
function chordDisplayName(rootPc, typeSym){
  const root = pcToName(rootPc);
  const def = chordTypeDef(typeSym);
  if(!def) return root + " " + typeSym;
  const lab = def.label;
  if(lab === "maj") return `${root} maj`;
  if(lab === "min") return `${root} min`;
  return `${root} ${lab}`;
}

function voicingKey(v){
  const frets6 = [];
  for(let s=6; s>=1; s--){
    frets6.push(v.fretsByString[s] ?? "x");
  }
  return `${v.typeSym}|${v.rootPc}|${frets6.join(",")}|${v.pattern.id}`;
}

function degreeLabel(rootPc, fretMap, stringNum){
  const f = fretMap[stringNum];
  if(f === undefined) return "";
  const iv = (pcAt(stringNum, f) - rootPc + 12) % 12;

  const map = {
    0:"1",
    1:"b9",
    2:"9",
    3:"#9",
    4:"3",
    5:"11",
    6:"#11",
    7:"5",
    8:"#5",
    9:"13",
    10:"b7",
    11:"7"
  };
  return map[iv] || "";
}

function noteNameForString(rootPc, fretMap, stringNum){
  const f = fretMap[stringNum];
  if(f === undefined) return "";
  return pcToName(pcAt(stringNum, f));
}

function notesPerString(v){
  // strings displayed low->high as E A D G B e? User wants string 1=top e, 2=B...
  // We'll output in order low->high under diagram: 6 5 4 3 2 1 but without labels.
  const arr = [];
  for(let s=6; s>=1; s--){
    arr.push(noteNameForString(v.rootPc, v.fretsByString, s));
  }
  return arr;
}

/* -------------------------
   SVGuitar integration
--------------------------*/
function buildSvguitarChord(v){
  const usedStrings = Object.keys(v.fretsByString).map(Number);
  const frets = usedStrings.map(s => v.fretsByString[s]);
  const minF = Math.min(...frets);
  const maxF = Math.max(...frets);
  const span = maxF - minF;

  // Ensure we draw span+1 frets so the top fret is visible (e.g. 5–9)
  const fretsOnChart = Math.max(5, span + 1);

  const position = minF;
  const fingers = [];

  // SVGuitar expects strings 1..6 (1=high e) for "fingers" config.
  // Our internal uses same numbering, so translate directly.
  for(const [sStr, fret] of Object.entries(v.fretsByString)){
    const s = Number(sStr);
    fingers.push({
      string: s,
      fret: (fret - position) + 1,
      text: degreeLabel(v.rootPc, v.fretsByString, s)
    });
  }

  return {
    title: "",
    position,
    fretsOnChart,
    fingers
  };
}

function addPositionLabel(svgContainer, position, color, fontSize){
  const wrap = svgContainer.parentElement;
  if(!wrap) return;
  const existing = wrap.querySelector(".posLabel");
  if(existing) existing.remove();

  const div = document.createElement("div");
  div.className = "posLabel";
  div.style.color = color;
  div.style.fontSize = fontSize + "px";
  div.textContent = position + "fr";
  wrap.appendChild(div);
}

function positionNoteLabels(svgContainer, noteRow){
  try{
    const svg = svgContainer.querySelector("svg");
    if(!svg || !noteRow) return;

    const labels = Array.from(noteRow.querySelectorAll(".noteLabel"));
    if(labels.length !== 6) return;

    const lines = Array.from(svg.querySelectorAll("line"));
    const xs = [];
    for(const ln of lines){
      const x1 = parseFloat(ln.getAttribute("x1"));
      const x2 = parseFloat(ln.getAttribute("x2"));
      const y1 = parseFloat(ln.getAttribute("y1"));
      const y2 = parseFloat(ln.getAttribute("y2"));
      if(!isFinite(x1)||!isFinite(x2)||!isFinite(y1)||!isFinite(y2)) continue;
      if(Math.abs(x1 - x2) < 0.25 && Math.abs(y1 - y2) > 18){
        xs.push((x1 + x2) / 2);
      }
    }

    let unique = Array.from(new Set(xs.map(x => Math.round(x * 10) / 10))).sort((a,b)=>a-b);
    while(unique.length > 6){
      unique.shift();
      if(unique.length > 6) unique.pop();
    }

    const rect = svg.getBoundingClientRect();
    const rectW = rect.width || 0;
    const contW = svgContainer.clientWidth || 0;
    const svgWpx = (rectW >= 160 ? rectW : (contW || rectW || 260));

    const vb = svg.viewBox && svg.viewBox.baseVal ? svg.viewBox.baseVal : null;
    const vbX = (vb && isFinite(vb.x)) ? vb.x : 0;
    const vbW = (vb && vb.width) ? vb.width : null;

    if(unique.length !== 6 || !vbW){
      noteRow.classList.remove("aligned");
      noteRow.style.width = svgWpx + "px";
      labels.forEach(l => l.style.left = "");
      return;
    }

    noteRow.classList.add("aligned");
    noteRow.style.width = svgWpx + "px";

    const scale = svgWpx / vbW;
    for(let i=0; i<6; i++){
      const xPx = (unique[i] - vbX) * scale;
      labels[i].style.left = xPx + "px";
    }
  }catch(e){
    try{
      noteRow.classList.remove("aligned");
      const labels = Array.from(noteRow.querySelectorAll(".noteLabel"));
      labels.forEach(l => l.style.left = "");
    }catch{}
  }
}

/* -------------------------
   Favourites store
--------------------------*/
function loadFaves(){
  try{
    const raw = localStorage.getItem(STORAGE_KEYS.faves);
    if(!raw) return {};
    return JSON.parse(raw);
  }catch{ return {}; }
}
function saveFaves(obj){
  localStorage.setItem(STORAGE_KEYS.faves, JSON.stringify(obj));
}
function toggleFave(v){
  const key = voicingKey(v);
  const f = loadFaves();
  if(f[key]){ delete f[key]; }
  else{
    f[key] = {
      rootPc: v.rootPc,
      typeSym: v.typeSym,
      patternId: v.pattern.id,
      fretsByString: v.fretsByString,
      savedAt: Date.now()
    };
  }
  saveFaves(f);
}
function isFaved(v){
  const key = voicingKey(v);
  const f = loadFaves();
  return !!f[key];
}

/* -------------------------
   Presets
--------------------------*/
function loadPresets(){
  try{
    const raw = localStorage.getItem(STORAGE_KEYS.presets);
    if(!raw) return [];
    return JSON.parse(raw);
  }catch{ return []; }
}
function savePresets(arr){
  localStorage.setItem(STORAGE_KEYS.presets, JSON.stringify(arr));
}
function rebuildPresetSelect(){
  const sel = document.getElementById("selPreset");
  sel.innerHTML = "";
  const presets = loadPresets();
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "Load preset…";
  sel.appendChild(opt0);
  for(const p of presets){
    const opt = document.createElement("option");
    opt.value = p.name;
    opt.textContent = p.name;
    sel.appendChild(opt);
  }
}

/* -------------------------
   UI Build (chips)
--------------------------*/
function buildChips(){
  // roots
  const rootWrap = document.getElementById("rootChips");
  rootWrap.innerHTML = "";
  ROOT_DISPLAY.forEach(n=>{
    const pc = nameToPc(n);
    const c = document.createElement("div");
    c.className = "chip";
    c.textContent = n;
    c.onclick = ()=>{
      if(state.selectedRoots.has(pc)) state.selectedRoots.delete(pc);
      else state.selectedRoots.add(pc);
      syncChips();
      rebuildDeck();
    };
    c.dataset.pc = pc;
    rootWrap.appendChild(c);
  });

  // types
  const typeWrap = document.getElementById("typeChips");
  typeWrap.innerHTML = "";
  CHORD_TYPES.forEach(t=>{
    const c = document.createElement("div");
    c.className = "chip";
    c.textContent = t.label; // no duplicate name
    c.onclick = ()=>{
      if(state.selectedTypes.has(t.sym)) state.selectedTypes.delete(t.sym);
      else state.selectedTypes.add(t.sym);
      syncChips();
      rebuildDeck();
    };
    c.dataset.sym = t.sym;
    typeWrap.appendChild(c);
  });

  // favourites filters
  const favRootWrap = document.getElementById("favRootChips");
  favRootWrap.innerHTML = "";
  ROOT_DISPLAY.forEach(n=>{
    const pc = nameToPc(n);
    const c = document.createElement("div");
    c.className = "chip";
    c.textContent = n;
    c.onclick = ()=>{
      if(favFilters.roots.has(pc)) favFilters.roots.delete(pc);
      else favFilters.roots.add(pc);
      syncFavChips();
      renderFavouritesScreen();
    };
    c.dataset.pc = pc;
    favRootWrap.appendChild(c);
  });

  const famWrap = document.getElementById("favFamChips");
  famWrap.innerHTML = "";
  FAM.forEach(f=>{
    const c = document.createElement("div");
    c.className = "chip";
    c.textContent = f.label;
    c.onclick = ()=>{
      if(favFilters.fams.has(f.id)) favFilters.fams.delete(f.id);
      else favFilters.fams.add(f.id);
      syncFavChips();
      renderFavouritesScreen();
    };
    c.dataset.id = f.id;
    famWrap.appendChild(c);
  });
}

function syncChips(){
  document.querySelectorAll("#rootChips .chip").forEach(el=>{
    const pc = Number(el.dataset.pc);
    el.classList.toggle("on", state.selectedRoots.has(pc));
  });
  document.querySelectorAll("#typeChips .chip").forEach(el=>{
    const sym = el.dataset.sym;
    el.classList.toggle("on", state.selectedTypes.has(sym));
  });
}

const favFilters = {
  roots: new Set(ROOT_DISPLAY.map(n=>nameToPc(n))), // default all
  fams: new Set(FAM.map(f=>f.id)), // default all
};
function syncFavChips(){
  document.querySelectorAll("#favRootChips .chip").forEach(el=>{
    const pc = Number(el.dataset.pc);
    el.classList.toggle("on", favFilters.roots.has(pc));
  });
  document.querySelectorAll("#favFamChips .chip").forEach(el=>{
    const id = el.dataset.id;
    el.classList.toggle("on", favFilters.fams.has(id));
  });
}

/* -------------------------
   Deck/random selection
--------------------------*/
function eligibleCombos(){
  const roots = Array.from(state.selectedRoots);
  const types = Array.from(state.selectedTypes);
  const combos = [];
  for(const r of roots){
    for(const t of types){
      combos.push({rootPc:r, typeSym:t});
    }
  }
  return combos;
}
function rebuildDeck(){
  const combos = eligibleCombos();
  state.deck = combos.slice();
  shuffle(state.deck);
  state.deckIdx = 0;
}
function pickNextCombo(){
  const combos = eligibleCombos();
  if(combos.length === 0) return null;

  if(state.mode === "shuffle"){
    const i = Math.floor(Math.random() * combos.length);
    return combos[i];
  }
  // deck
  if(state.deck.length !== combos.length){
    rebuildDeck();
  }
  if(state.deckIdx >= state.deck.length){
    rebuildDeck();
  }
  const item = state.deck[state.deckIdx++];
  return item;
}
function shuffle(arr){
  for(let i=arr.length-1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

/* -------------------------
   Rendering (Trainer)
--------------------------*/
let autoTimer = null;

function stopAuto(){
  if(autoTimer){
    clearInterval(autoTimer);
    autoTimer = null;
  }
}
function startAuto(){
  stopAuto();
  if(!state.autoAdvance) return;
  const ms = Math.max(1, state.autoSecs) * 1000;
  autoTimer = setInterval(()=> nextChord(), ms);
}

function play(){
  if(state.selectedRoots.size === 0 || state.selectedTypes.size === 0){
    alert("Select at least one root note and one chord type in Setup.");
    return;
  }
  nextChord(true);
  startAuto();
}

function nextChord(fromPlay=false){
  const combo = pickNextCombo();
  if(!combo){
    document.getElementById("curChordName").textContent = "—";
    document.getElementById("curChordMeta").textContent = "No selections.";
    return;
  }
  state.current = combo;
  const name = chordDisplayName(combo.rootPc, combo.typeSym);
  document.getElementById("curChordName").textContent = name;
  document.getElementById("curChordMeta").textContent = fromPlay ? "Ready. Tap Display to see voicings." : "Tap Display for voicings, or Next to shuffle.";
  document.getElementById("voicingArea").innerHTML = "";
}

function renderVoicings(){
  if(!state.current) return;
  const {rootPc, typeSym} = state.current;
  const voicings = generateVoicings(rootPc, typeSym);

  const area = document.getElementById("voicingArea");
  area.innerHTML = "";

  const grid = document.createElement("div");
  grid.className = "voicingGrid";

  voicings.forEach((v)=>{
    const card = document.createElement("div");
    card.className = "voicingCard";

    const head = document.createElement("div");
    head.className = "voicingHead";

    const left = document.createElement("div");
    const t1 = document.createElement("div");
    t1.className = "vcTitle";
    t1.textContent = chordDisplayName(v.rootPc, v.typeSym);
    const t2 = document.createElement("div");
    t2.className = "vcSub";
    t2.textContent = v.pattern.label;
    left.appendChild(t1);
    left.appendChild(t2);

    const star = document.createElement("div");
    star.className = "starBtn" + (isFaved(v) ? " on" : "");
    star.textContent = "★";
    star.onclick = (e)=>{
      e.stopPropagation();
      toggleFave(v);
      star.classList.toggle("on", isFaved(v));
    };

    head.appendChild(left);
    head.appendChild(star);

    const svgWrap = document.createElement("div");
    svgWrap.className = "svgWrap";
    const svgContainer = document.createElement("div");
    svgContainer.style.width = "340px";
    svgContainer.style.maxWidth = "100%";
    svgContainer.style.margin = "0 auto";
    svgWrap.appendChild(svgContainer);

    const noteRow = document.createElement("div");
    noteRow.className = "noteRow";
    noteRow.style.width = svgContainer.style.width;

    const notes = notesPerString(v);
    for(const n of notes){
      const cell = document.createElement("div");
      cell.className = "noteLabel";
      cell.textContent = n;
      noteRow.appendChild(cell);
    }

    card.appendChild(head);
    card.appendChild(svgWrap);
    card.appendChild(noteRow);

    // Render chord diagram
    const ink = "#f3f6ff";
    const accent = "rgba(124,92,255,.95)";

    if(typeof svguitar !== "undefined"){
      const chordObj = buildSvguitarChord(v);
      const chart = new svguitar.SVGuitarChord(svgContainer);
      chart.configure({
        orientation: "vertical",
        style: "normal",
        strings: 6,
        frets: chordObj.fretsOnChart,
        titleFontSize: 14,
        fretLabelPosition: "left",
        fretLabelFontSize: 14,
        noPosition: true,
        titleColor: "transparent",
        fretLabelColor: "transparent",
        sidePadding: 0.45,
        color: ink,
        stringColor: ink,
        fretColor: ink,
        tuningsColor: ink,
        backgroundColor: "none",
        fingerColor: accent,
        fingerStrokeColor: ink,
        fingerStrokeWidth: 1,
        fingerSize: 0.92,
        fingerTextSize: 24,
        strokeWidth: 2,
      }).chord({
        title: "",
        position: chordObj.position,
        fingers: chordObj.fingers,
        barres: [],
        capo: false
      }).draw();
      // v11: ensure SVG scales to container (prevents tiny diagrams)
      const __svg = svgContainer.querySelector('svg');
      if(__svg){ __svg.style.width='100%'; __svg.style.height='auto'; __svg.style.display='block'; }

      requestAnimationFrame(() => {
        positionNoteLabels(svgContainer, noteRow);
        addPositionLabel(svgContainer, chordObj.position, ink, 44);
      });
    }else{
      const p = document.createElement("div");
      p.className = "small";
      p.textContent = "SVGuitar failed to load (diagrams unavailable).";
      card.appendChild(p);
    }

    grid.appendChild(card);
  });

  area.appendChild(grid);
}

/* -------------------------
   Favourites screen rendering
--------------------------*/
function renderFavouritesScreen(){
  const area = document.getElementById("favesArea");
  area.innerHTML = "";

  const f = loadFaves();
  const all = Object.entries(f).map(([key, item])=>({key, ...item}));
  if(all.length === 0){
    const p = document.createElement("div");
    p.className = "small";
    p.textContent = "No favourites yet. Star a voicing on the Trainer screen.";
    area.appendChild(p);
    return;
  }

  const filtered = all.filter(item=>{
    if(!favFilters.roots.has(item.rootPc)) return false;
    const fam = famForType(item.typeSym);
    if(!favFilters.fams.has(fam)) return false;
    return true;
  });

  const grid = document.createElement("div");
  grid.className = "voicingGrid";

  filtered.forEach(item=>{
    const v = {
      rootPc: item.rootPc,
      typeSym: item.typeSym,
      pattern: PATTERNS.find(p=>p.id===item.patternId) || {id:item.patternId,label:item.patternId,strings:[],kind:"four"},
      fretsByString: item.fretsByString
    };

    const card = document.createElement("div");
    card.className = "voicingCard";

    const head = document.createElement("div");
    head.className = "voicingHead";

    const left = document.createElement("div");
    const t1 = document.createElement("div");
    t1.className = "vcTitle";
    t1.textContent = chordDisplayName(v.rootPc, v.typeSym);
    const t2 = document.createElement("div");
    t2.className = "vcSub";
    t2.textContent = v.pattern.label;
    left.appendChild(t1);
    left.appendChild(t2);

    const star = document.createElement("div");
    star.className = "starBtn on";
    star.textContent = "★";
    star.onclick = ()=>{
      const f = loadFaves();
      delete f[item.key];
      saveFaves(f);
      renderFavouritesScreen();
    };

    head.appendChild(left);
    head.appendChild(star);

    const svgWrap = document.createElement("div");
    svgWrap.className = "svgWrap";
    const svgContainer = document.createElement("div");
    svgContainer.style.width = "340px";
    svgContainer.style.maxWidth = "100%";
    svgContainer.style.margin = "0 auto";
    svgWrap.appendChild(svgContainer);

    const noteRow = document.createElement("div");
    noteRow.className = "noteRow";
    noteRow.style.width = svgContainer.style.width;

    const notes = notesPerString(v);
    for(const n of notes){
      const cell = document.createElement("div");
      cell.className = "noteLabel";
      cell.textContent = n;
      noteRow.appendChild(cell);
    }

    card.appendChild(head);
    card.appendChild(svgWrap);
    card.appendChild(noteRow);

    const ink = "#f3f6ff";
    const accent = "rgba(124,92,255,.95)";

    if(typeof svguitar !== "undefined"){
      const chordObj = buildSvguitarChord(v);
      const chart = new svguitar.SVGuitarChord(svgContainer);
      chart.configure({
        orientation: "vertical",
        style: "normal",
        strings: 6,
        frets: chordObj.fretsOnChart,
        titleFontSize: 14,
        fretLabelPosition: "left",
        fretLabelFontSize: 14,
        noPosition: true,
        titleColor: "transparent",
        fretLabelColor: "transparent",
        sidePadding: 0.45,
        color: ink,
        stringColor: ink,
        fretColor: ink,
        tuningsColor: ink,
        backgroundColor: "none",
        fingerColor: accent,
        fingerStrokeColor: ink,
        fingerStrokeWidth: 1,
        fingerSize: 0.92,
        fingerTextSize: 24,
        strokeWidth: 2,
      }).chord({
        title: "",
        position: chordObj.position,
        fingers: chordObj.fingers,
        barres: [],
        capo: false
      }).draw();
      const __svg = svgContainer.querySelector('svg');
      if(__svg){ __svg.style.width='100%'; __svg.style.height='auto'; __svg.style.display='block'; }

      requestAnimationFrame(() => {
        positionNoteLabels(svgContainer, noteRow);
        addPositionLabel(svgContainer, chordObj.position, ink, 44);
      });
    }

    grid.appendChild(card);
  });

  area.appendChild(grid);
}

/* -------------------------
   Screen navigation
--------------------------*/
function setActiveTab(which){
  document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
  document.getElementById("tab"+which).classList.add("active");
  document.getElementById("screenSetup").style.display = (which==="Setup") ? "" : "none";
  document.getElementById("screenTrainer").style.display = (which==="Trainer") ? "" : "none";
  document.getElementById("screenFaves").style.display = (which==="Faves") ? "" : "none";
}

document.getElementById("tabSetup").onclick = ()=>{ setActiveTab("Setup"); stopAuto(); };
document.getElementById("tabTrainer").onclick = ()=>{ setActiveTab("Trainer"); };
document.getElementById("tabFaves").onclick = ()=>{ setActiveTab("Faves"); renderFavouritesScreen(); };

/* -------------------------
   Setup UI wiring
--------------------------*/
function syncFromInputs(){
  state.preferTop = document.getElementById("chkPreferTop").checked;
  state.showTriads = document.getElementById("chkShowTriads").checked;
  state.showFour = document.getElementById("chkShowFour").checked;
  state.allowBassTop = document.getElementById("chkAllowBassTop").checked;

  state.minFret = Number(document.getElementById("numMinFret").value);
  state.maxFret = Number(document.getElementById("numMaxFret").value);
  state.maxSpan = Number(document.getElementById("numMaxSpan").value);
  state.maxVoicings = Number(document.getElementById("numMaxVoicings").value);

  state.mode = document.getElementById("selMode").value;
  state.autoAdvance = document.getElementById("chkAutoAdvance").checked;
  state.autoSecs = Number(document.getElementById("numAutoSecs").value);
}

["chkPreferTop","chkShowTriads","chkShowFour","chkAllowBassTop","numMinFret","numMaxFret","numMaxSpan","numMaxVoicings","selMode","chkAutoAdvance","numAutoSecs"].forEach(id=>{
  document.getElementById(id).addEventListener("change", ()=>{
    syncFromInputs();
    rebuildDeck();
    startAuto();
  });
});

document.getElementById("btnSelectAllRoots").onclick = ()=>{
  state.selectedRoots = new Set(ROOT_DISPLAY.map(n=>nameToPc(n)));
  syncChips();
  rebuildDeck();
};
document.getElementById("btnClearRoots").onclick = ()=>{
  state.selectedRoots.clear();
  syncChips();
  rebuildDeck();
};
document.getElementById("btnSelectAllTypes").onclick = ()=>{
  state.selectedTypes = new Set(CHORD_TYPES.map(t=>t.sym));
  syncChips();
  rebuildDeck();
};
document.getElementById("btnClearTypes").onclick = ()=>{
  state.selectedTypes.clear();
  syncChips();
  rebuildDeck();
};

document.getElementById("btnGoTrainer").onclick = ()=>{
  setActiveTab("Trainer");
};

document.getElementById("btnSavePreset").onclick = ()=>{
  const name = prompt("Preset name?");
  if(!name) return;
  const presets = loadPresets();
  const payload = {
    name,
    selectedRoots: Array.from(state.selectedRoots),
    selectedTypes: Array.from(state.selectedTypes),
    preferTop: state.preferTop,
    showTriads: state.showTriads,
    showFour: state.showFour,
    allowBassTop: state.allowBassTop,
    minFret: state.minFret,
    maxFret: state.maxFret,
    maxSpan: state.maxSpan,
    maxVoicings: state.maxVoicings,
    mode: state.mode,
    autoAdvance: state.autoAdvance,
    autoSecs: state.autoSecs
  };
  const existingIdx = presets.findIndex(p=>p.name===name);
  if(existingIdx>=0) presets[existingIdx]=payload;
  else presets.push(payload);
  savePresets(presets);
  rebuildPresetSelect();
  document.getElementById("selPreset").value = name;
};

document.getElementById("selPreset").onchange = ()=>{
  const name = document.getElementById("selPreset").value;
  if(!name) return;
  const presets = loadPresets();
  const p = presets.find(x=>x.name===name);
  if(!p) return;

  state.selectedRoots = new Set(p.selectedRoots);
  state.selectedTypes = new Set(p.selectedTypes);
  state.preferTop = p.preferTop;
  state.showTriads = p.showTriads;
  state.showFour = p.showFour;
  state.allowBassTop = p.allowBassTop;
  state.minFret = p.minFret;
  state.maxFret = p.maxFret;
  state.maxSpan = p.maxSpan;
  state.maxVoicings = p.maxVoicings;
  state.mode = p.mode;
  state.autoAdvance = p.autoAdvance;
  state.autoSecs = p.autoSecs;

  document.getElementById("chkPreferTop").checked = state.preferTop;
  document.getElementById("chkShowTriads").checked = state.showTriads;
  document.getElementById("chkShowFour").checked = state.showFour;
  document.getElementById("chkAllowBassTop").checked = state.allowBassTop;
  document.getElementById("numMinFret").value = state.minFret;
  document.getElementById("numMaxFret").value = state.maxFret;
  document.getElementById("numMaxSpan").value = state.maxSpan;
  document.getElementById("numMaxVoicings").value = state.maxVoicings;
  document.getElementById("selMode").value = state.mode;
  document.getElementById("chkAutoAdvance").checked = state.autoAdvance;
  document.getElementById("numAutoSecs").value = state.autoSecs;

  syncChips();
  rebuildDeck();
};

document.getElementById("btnDeletePreset").onclick = ()=>{
  const name = document.getElementById("selPreset").value;
  if(!name) return;
  if(!confirm("Delete preset '" + name + "'?")) return;
  const presets = loadPresets().filter(p=>p.name !== name);
  savePresets(presets);
  rebuildPresetSelect();
};

/* -------------------------
   Trainer wiring
--------------------------*/
document.getElementById("btnPlay").onclick = ()=>{ syncFromInputs(); play(); };
document.getElementById("btnNext").onclick = ()=>{ syncFromInputs(); nextChord(); };
document.getElementById("btnDisplay").onclick = ()=>{ syncFromInputs(); renderVoicings(); };

/* -------------------------
   Faves wiring
--------------------------*/
document.getElementById("btnFavesRefresh").onclick = ()=>{ renderFavouritesScreen(); };
document.getElementById("btnFavesClearAll").onclick = ()=>{
  if(!confirm("Clear all favourites?")) return;
  saveFaves({});
  renderFavouritesScreen();
};

document.getElementById("btnFavRootsAll").onclick = ()=>{
  favFilters.roots = new Set(ROOT_DISPLAY.map(n=>nameToPc(n)));
  syncFavChips();
  renderFavouritesScreen();
};
document.getElementById("btnFavRootsNone").onclick = ()=>{
  favFilters.roots.clear();
  syncFavChips();
  renderFavouritesScreen();
};
document.getElementById("btnFavFamAll").onclick = ()=>{
  favFilters.fams = new Set(FAM.map(f=>f.id));
  syncFavChips();
  renderFavouritesScreen();
};
document.getElementById("btnFavFamNone").onclick = ()=>{
  favFilters.fams.clear();
  syncFavChips();
  renderFavouritesScreen();
};

/* -------------------------
   Init
--------------------------*/
try{
  buildChips();
  syncChips();
  syncFavChips();
  rebuildPresetSelect();

  // default selections (a helpful starter)
  if(state.selectedRoots.size === 0){
    state.selectedRoots = new Set([nameToPc("C")]);
  }
  if(state.selectedTypes.size === 0){
    state.selectedTypes = new Set(["maj","min","7","maj7","m7"]);
  }
  syncChips();
  rebuildDeck();
  startAuto();
}catch(e){
  showError("Init error:\n" + (e && e.message ? e.message : String(e)));
}
</script>
</body>
</html>
